import os
import time
from multiprocessing import Process, Queue


"""
多进程的通信和基本用法

不同进程之间是有数据隔离的，即一个进程更改了全局变量后，其他进程不知道该全局变量被更改，还是会取得未更改时的全局变量。
因此，在实现多进程之前需要解决进程之间的数据隔离问题，实现不同进程之间的通信，这样才能实现多进程之间的任务分配。
常用的方法是使用队列，例如，将需要爬取的不同网址放在同一队列中，不同进程从同一队列中取出不同的网址进行爬取。
如果不使用队列，那么每个进程都会对所有网址进行爬取，费时且低效。

下面将多个网址放入一个队列中，在每个进程中取出队列中的一个网址进行爬取，实现网址爬取任务的分配
"""


def task(q):
    url = q.get()
    print('子进程开始执行：', url, os.getpid())
    time.sleep(2)
    print('子进程执行结束：', url, os.getpid())


if __name__ == '__main__':
    process_list = []
    q = Queue()  # 创建队列,用于进程间通信
    for i in range(10):
        q.put(f"url{i}")

    start_time = time.time()
    for i in range(10):
        p = Process(target=task, args=(q,))
        p.start()  # 开启子进程
        process_list.append(p)

    for p in process_list:
        p.join()  # 等待子进程执行完毕

    print('父进程执行结束')
    print(f"总耗时：{time.time() - start_time}")

"""
代码运行结果如下图所示。可发现每个进程都分配到了不同的网址，即实现了不同进程之间的任务分配。每个进程中使用time模块延时了2秒，如果不使用多进程至少要耗时20秒，使用多进程来执行只耗时约3秒。

子进程开始执行： url0 6584
子进程开始执行： url1 10320
子进程开始执行： url2 19856
子进程开始执行： url3 4632
子进程开始执行： url4 6692
子进程开始执行： url5 288
子进程开始执行： url6 11192
子进程开始执行： url7 13376
子进程开始执行： url8 17956
子进程开始执行： url9 14524
子进程执行结束： url0 6584
子进程执行结束： url1 10320
子进程执行结束： url3 4632
子进程执行结束： url2 19856
子进程执行结束： url6 11192
子进程执行结束： url7 13376
子进程执行结束： url4 6692
子进程执行结束： url5 288
子进程执行结束： url9 14524
子进程执行结束： url8 17956
父进程执行结束
总耗时：2.1888668537139893
"""
